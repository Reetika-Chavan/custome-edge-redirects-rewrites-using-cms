import * as fs from "fs";
import * as path from "path";
import { fetchRules } from "./fetch-rules.js";

/**
 * Updates the functions/[proxy].edge.js file with fetched rules
 * Fetches rules from Contentstack and generates the edge function
 */
export async function updateEdgeFile() {
  try {
    // Fetch rules from Contentstack
    const { redirectRules, rewriteRules } = await fetchRules();

    const edgeFile = path.join(process.cwd(), "functions", "[proxy].edge.js");

    // Ensure functions directory exists
    const functionsDir = path.dirname(edgeFile);
    if (!fs.existsSync(functionsDir)) {
      fs.mkdirSync(functionsDir, { recursive: true });
    }

    // Generate edge function code
    const timestamp = new Date().toISOString();
    const edgeCode = `// This file is auto-generated by scripts/update-edge-file.js
// Do not edit manually - changes will be overwritten
// Generated at: ${timestamp}
// Redirects: ${redirectRules.length} | Rewrites: ${rewriteRules.length}

/**
 * Edge function to apply redirects and rewrites
 * Rules are fetched from Contentstack and injected at build/update time
 */
export default async function handler(request) {
  const url = new URL(request.url);
  const pathname = url.pathname;

  // Redirects (fetched from Contentstack)
  const redirects = ${JSON.stringify(redirectRules, null, 2)};

  // Rewrites (fetched from Contentstack)
  const rewrites = ${JSON.stringify(rewriteRules, null, 2)};

  // Apply redirects first
  const redirect = redirects.find(
    (r) =>
      pathname === r.from ||
      pathname.startsWith(r.from + "/") ||
      matchPattern(pathname, r.from)
  );

  if (redirect) {
    const destination = redirect.to.startsWith("http")
      ? redirect.to
      : \`\${url.origin}\${redirect.to}\`;

    const statusCode = typeof redirect.type === "number" ? redirect.type : 301;

    // Merge custom headers with Location header
    const headers = new Headers({
      Location: destination,
      ...redirect.headers,
    });

    return new Response(null, {
      status: statusCode,
      headers: headers,
    });
  }

  // Apply rewrites
  const rewrite = rewrites.find(
    (r) =>
      pathname === r.from ||
      pathname.startsWith(r.from + "/") ||
      matchPattern(pathname, r.from)
  );

  if (rewrite) {
    const destination = rewrite.to.startsWith("http")
      ? rewrite.to
      : \`\${url.origin}\${rewrite.to}\`;

    // Merge request headers with custom headers
    const requestHeaders = new Headers(request.headers);
    Object.entries(rewrite.requestHeaders || {}).forEach(([key, value]) => {
      requestHeaders.set(key, value);
    });

    // For rewrite, fetch the destination and return it
    const response = await fetch(destination, {
      method: request.method,
      headers: requestHeaders,
      body: request.body,
    });

    // Apply response headers if specified
    const responseHeaders = new Headers(response.headers);
    Object.entries(rewrite.responseHeaders || {}).forEach(([key, value]) => {
      responseHeaders.set(key, value);
    });

    // Return response with updated headers
    return new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
    });
  }

  // No match found - return undefined to pass through to origin
  // This is the Contentstack Launch pattern for forwarding to Next.js
  return;
}

// Simple pattern matching (supports * wildcard)
function matchPattern(pathname, pattern) {
  if (!pattern.includes("*")) {
    return pathname === pattern;
  }

  // Convert pattern to regex
  const regexPattern = pattern.replace(/\\*/g, ".*").replace(/\\//g, "\\\\/");

  const regex = new RegExp(\`^\${regexPattern}$\`);
  return regex.test(pathname);
}
`;

    // Write the updated file
    fs.writeFileSync(edgeFile, edgeCode, "utf-8");

    console.log(`✅ [proxy].edge.js updated successfully!`);
    console.log(`   - ${redirectRules.length} redirects`);
    console.log(`   - ${rewriteRules.length} rewrites`);
    console.log(`   - Generated at: ${timestamp}`);

    return { redirectRules, rewriteRules, timestamp };
  } catch (error) {
    console.error("❌ Error updating edge file:", error);
    throw error;
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  updateEdgeFile().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}
