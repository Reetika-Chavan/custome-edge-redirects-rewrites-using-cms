import * as fs from "fs";
import * as path from "path";
import { fetchRules } from "./fetch-rules.js";

/**
 * Updates the functions/[proxy].edge.js file with fetched rules
 * Fetches rules from Contentstack and generates the edge function
 */
export async function updateEdgeFile() {
  try {
    // Fetch rules from Contentstack
    const { redirectRules, rewriteRules } = await fetchRules();

    const edgeFile = path.join(process.cwd(), "functions", "[proxy].edge.js");

    // Ensure functions directory exists
    const functionsDir = path.dirname(edgeFile);
    if (!fs.existsSync(functionsDir)) {
      fs.mkdirSync(functionsDir, { recursive: true });
    }

    // Generate edge function code
    const timestamp = new Date().toISOString();
    const edgeCode = `// This file is auto-generated by scripts/update-edge-file.js
// Do not edit manually - changes will be overwritten
// Generated at: ${timestamp}

/**
 * Edge function to apply redirects and rewrites
 * Rules are fetched from Contentstack and injected at build/update time
 */
export default async function middleware(req, context) {
  const url = new URL(req.url);
  const pathname = url.pathname;

  // Redirects (fetched from Contentstack)
  const redirects = ${JSON.stringify(redirectRules, null, 2)};

  // Rewrites (fetched from Contentstack)
  const rewrites = ${JSON.stringify(rewriteRules, null, 2)};

  // Apply redirects first
  const redirect = redirects.find(
    (r) =>
      pathname === r.from ||
      pathname.startsWith(r.from + "/") ||
      matchPattern(pathname, r.from)
  );

  if (redirect) {
    const destination = redirect.to.startsWith("http")
      ? redirect.to
      : \`\${url.origin}\${redirect.to}\`;

    const statusCode = typeof redirect.type === "number" ? redirect.type : 301;

    return new Response(null, {
      status: statusCode,
      headers: {
        Location: destination,
      },
    });
  }

  // Apply rewrites
  const rewrite = rewrites.find(
    (r) =>
      pathname === r.from ||
      pathname.startsWith(r.from + "/") ||
      matchPattern(pathname, r.from)
  );

  if (rewrite) {
    const destination = rewrite.to.startsWith("http")
      ? rewrite.to
      : \`\${url.origin}\${rewrite.to}\`;

    // For rewrite, fetch the destination and return it
    const response = await fetch(destination, {
      method: req.method,
      headers: req.headers,
      body: req.body,
    });

    return response;
  }

  // No match found, continue with normal request
  return context.next();
}

// Simple pattern matching (supports * wildcard)
function matchPattern(pathname, pattern) {
  if (!pattern.includes("*")) {
    return pathname === pattern;
  }

  // Convert pattern to regex
  const regexPattern = pattern.replace(/\\*/g, ".*").replace(/\\//g, "\\\\/");

  const regex = new RegExp(\`^\${regexPattern}$\`);
  return regex.test(pathname);
}
`;

    // Write the updated file
    fs.writeFileSync(edgeFile, edgeCode, "utf-8");

    console.log(`✅ [proxy].edge.js updated with redirects & rewrites`);
    console.log(`   - ${redirectRules.length} redirects`);
    console.log(`   - ${rewriteRules.length} rewrites`);
  } catch (error) {
    console.error("❌ Error updating edge file:", error);
    throw error;
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  updateEdgeFile().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}
