// This file is auto-generated by scripts/update-edge-file.js
// Do not edit manually - changes will be overwritten
// Generated at: PLACEHOLDER_TIMESTAMP

/**
 * Edge function to apply redirects and rewrites
 * Rules are fetched from Contentstack and injected at build/update time
 */
export default async function handler(request) {
  const url = new URL(request.url);
  const pathname = url.pathname;

  // Redirects (fetched from Contentstack)
  const redirects = [];

  // Rewrites (fetched from Contentstack)
  const rewrites = [];

  // Apply redirects first
  const redirect = redirects.find(
    (r) =>
      pathname === r.from ||
      pathname.startsWith(r.from + "/") ||
      matchPattern(pathname, r.from)
  );

  if (redirect) {
    const destination = redirect.to.startsWith("http")
      ? redirect.to
      : `${url.origin}${redirect.to}`;

    const statusCode = typeof redirect.type === "number" ? redirect.type : 301;

    // Merge custom headers with Location header
    const headers = new Headers({
      Location: destination,
      ...redirect.headers,
    });

    return new Response(null, {
      status: statusCode,
      headers: headers,
    });
  }

  // Apply rewrites
  const rewrite = rewrites.find(
    (r) =>
      pathname === r.from ||
      pathname.startsWith(r.from + "/") ||
      matchPattern(pathname, r.from)
  );

  if (rewrite) {
    const destination = rewrite.to.startsWith("http")
      ? rewrite.to
      : `${url.origin}${rewrite.to}`;

    // Merge request headers with custom headers
    const requestHeaders = new Headers(request.headers);
    Object.entries(rewrite.requestHeaders || {}).forEach(([key, value]) => {
      requestHeaders.set(key, value);
    });

    // For rewrite, fetch the destination and return it
    const response = await fetch(destination, {
      method: request.method,
      headers: requestHeaders,
      body: request.body,
    });

    // Apply response headers if specified
    const responseHeaders = new Headers(response.headers);
    Object.entries(rewrite.responseHeaders || {}).forEach(([key, value]) => {
      responseHeaders.set(key, value);
    });

    // Return response with updated headers
    return new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
    });
  }

  // No match found, forward request to origin (Contentstack Launch pattern)
  return fetch(request);
}

// Simple pattern matching (supports * wildcard)
function matchPattern(pathname, pattern) {
  if (!pattern.includes("*")) {
    return pathname === pattern;
  }

  // Convert pattern to regex
  const regexPattern = pattern.replace(/\*/g, ".*").replace(/\//g, "\\/");

  const regex = new RegExp(`^${regexPattern}$`);
  return regex.test(pathname);
}
